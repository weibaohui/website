[
{
	"uri": "https://gin-gonic.com/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Gin is a web framework written in Go (Golang). It features a martini-like API with much better performance, up to 40 times faster thanks to httprouter. If you need performance and good productivity, you will love Gin.\nIn this section we will walk through what Gin is, what problems it solves, and how it can help your project.\nOr, if you are ready to use Gin in to your project, visit the Quickstart.\nFeatures Fast Radix tree based routing, small memory foot print. No reflection. Predictable API performance.\nMiddleware support A incoming HTTP request can be handled by a chain of middlewares and the final action. For example: Logger, Authorization, GZIP and finally post a message in the DB.\nCrash-free Gin can catch a panic occurred during a HTTP request and recover it. This way, your server will be always available. It’s also possible to report this panic to Sentry for example!\nJSON validation Gin can parse and validate the JSON of a request, checking for example the existence of required values.\nRoutes grouping Organize your routes better. Authorization required vs non required, different API versions\u0026hellip; In addition, the groups can be nested unlimitedly without degrading performance.\nError management Gin provides a convenient way to collect all the errors occurred during a HTTP request. Eventually, a middleware can write them to a log file, to a database and send them through the network.\nRendering built-in Gin provides a easy to use API for JSON, XML and HTML rendering.\nExtendable Creating a new middleware is so easy, just check out the sample codes.\n"
},
{
	"uri": "https://gin-gonic.com/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "  Requirements Installation Getting started  In this quickstart, we’ll glean insights from code segments and learn how to:\nRequirements  Go 1.6 or above  Go 1.7 or Go 1.8 will be required soon.\n Installation To install Gin package, you need to install Go and set your Go workspace first.\n Download and install it:  $ go get -u github.com/gin-gonic/gin  Import it in your code:  import \u0026#34;github.com/gin-gonic/gin\u0026#34;  (Optional) Import net/http. This is required for example if using constants such as http.StatusOK.  import \u0026#34;net/http\u0026#34; Use a vendor tool like Govendor  go get govendor  $ go get github.com/kardianos/govendor  Create your project folder and cd inside  $ mkdir -p $GOPATH/src/github.com/myusername/project \u0026amp;\u0026amp; cd \u0026#34;$_\u0026#34;  Vendor init your project and add gin  $ govendor init $ govendor fetch github.com/gin-gonic/gin@v1.3  Copy a starting template inside your project  $ curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go \u0026gt; main.go  Run your project  $ go run main.go Getting Started Unsure how to write and execute Go code? Click here.\n First, create a file called example.go:\n# assume the following codes in example.go file $ touch example.go Next, put the following code inside of example.go:\npackage main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } And, You can run the code via go run example.go:\n# run example.go and visit 0.0.0.0:8080/ping on browser $ go run example.go"
},
{
	"uri": "https://gin-gonic.com/benchmarks/",
	"title": "Benchmarks",
	"tags": [],
	"description": "",
	"content": "Gin uses a custom version of HttpRouter\nSee all benchmarks\n   Benchmark name (1) (2) (3) (4)     BenchmarkGin_GithubAll 30000 48375 0 0   BenchmarkAce_GithubAll 10000 134059 13792 167   BenchmarkBear_GithubAll 5000 534445 86448 943   BenchmarkBeego_GithubAll 3000 592444 74705 812   BenchmarkBone_GithubAll 200 6957308 698784 8453   BenchmarkDenco_GithubAll 10000 158819 20224 167   BenchmarkEcho_GithubAll 10000 154700 6496 203   BenchmarkGocraftWeb_GithubAll 3000 570806 131656 1686   BenchmarkGoji_GithubAll 2000 818034 56112 334   BenchmarkGojiv2_GithubAll 2000 1213973 274768 3712   BenchmarkGoJsonRest_GithubAll 2000 785796 134371 2737   BenchmarkGoRestful_GithubAll 300 5238188 689672 4519   BenchmarkGorillaMux_GithubAll 100 10257726 211840 2272   BenchmarkHttpRouter_GithubAll 20000 105414 13792 167   BenchmarkHttpTreeMux_GithubAll 10000 319934 65856 671   BenchmarkKocha_GithubAll 10000 209442 23304 843   BenchmarkLARS_GithubAll 20000 62565 0 0   BenchmarkMacaron_GithubAll 2000 1161270 204194 2000   BenchmarkMartini_GithubAll 200 9991713 226549 2325   BenchmarkPat_GithubAll 200 5590793 1499568 27435   BenchmarkPossum_GithubAll 10000 319768 84448 609   BenchmarkR2router_GithubAll 10000 305134 77328 979   BenchmarkRivet_GithubAll 10000 132134 16272 167   BenchmarkTango_GithubAll 3000 552754 63826 1618   BenchmarkTigerTonic_GithubAll 1000 1439483 239104 5374   BenchmarkTraffic_GithubAll 100 11383067 2659329 21848   BenchmarkVulcan_GithubAll 5000 394253 19894 609     (1): Total Repetitions achieved in constant time, higher means more confident result (2): Single Repetition Duration (ns/op), lower is better (3): Heap Memory (B/op), lower is better (4): Average Allocations per Repetition (allocs/op), lower is better  "
},
{
	"uri": "https://gin-gonic.com/features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": " Gin v1 stable features:  Zero allocation router.\n Still the fastest http router and framework. From routing to writing.\n Complete suite of unit tests.\n Battle tested.\n API frozen, new releases will not break your code.\n  "
},
{
	"uri": "https://gin-gonic.com/jsoniter/",
	"title": "Jsoniter",
	"tags": [],
	"description": "",
	"content": " Build with jsoniter Gin uses encoding/json as default json package but you can change to jsoniter by build from other tags.\n$ go build -tags=jsoniter ."
},
{
	"uri": "https://gin-gonic.com/api-example/",
	"title": "API Example",
	"tags": [],
	"description": "",
	"content": "The section lists api usage.\n"
},
{
	"uri": "https://gin-gonic.com/testing/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": " How to write test case for Gin? The net/http/httptest package is preferable way for HTTP testing.\npackage main func setupRouter() *gin.Engine { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) return r } func main() { r := setupRouter() r.Run(\u0026#34;:8080\u0026#34;) } Test for code example above:\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestPingRoute(t *testing.T) { router := setupRouter() w := httptest.NewRecorder() req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/ping\u0026#34;, nil) router.ServeHTTP(w, req) assert.Equal(t, 200, w.Code) assert.Equal(t, \u0026#34;pong\u0026#34;, w.Body.String()) }"
},
{
	"uri": "https://gin-gonic.com/users/",
	"title": "Users",
	"tags": [],
	"description": "",
	"content": " Awesome project lists using Gin web framework:  drone: Drone is a Continuous Delivery platform built on Docker, written in Go.\n gorush: A push notification server written in Go.\n fnproject: The container native, cloud agnostic serverless platform.\n photoprism: Personal photo management powered by Go and Google TensorFlow.\n krakend: Ultra performant API Gateway with middlewares.\n picfit: An image resizing server written in Go.\n  "
},
{
	"uri": "https://gin-gonic.com/faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": "TODO: record some frequently asked question from GitHub Issue tab.\n"
},
{
	"uri": "https://gin-gonic.com/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gin-gonic.com/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Gin\n"
},
{
	"uri": "https://gin-gonic.com/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "  Gin The fastest full-featured web framework for Go   What is Gin? Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance \u0026ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin.\n Features    Quickstart   How to use Gin? We provide some API usage examples and lists some public known Gin\u0026rsquo;s user.\n APIExample    Userlist   How to contribute to Gin?  Help people on the discussion forums Tell us your success stories using Gin Tell us how we can improve Gin and help us do it Contribute to an existing library   Discussion forum    Contribute   "
},
{
	"uri": "https://gin-gonic.com/api-example/ascii-json/",
	"title": "AsciiJSON",
	"tags": [],
	"description": "",
	"content": "Using AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII chracters.\nfunc main() { r := gin.Default() r.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { data := map[string]interface{}{ \u0026#34;lang\u0026#34;: \u0026#34;GO语言\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\u0026lt;br\u0026gt;\u0026#34;, } // will output : {\u0026#34;lang\u0026#34;:\u0026#34;GO\\u8bed\\u8a00\u0026#34;,\u0026#34;tag\u0026#34;:\u0026#34;\\u003cbr\\u003e\u0026#34;} \tc.AsciiJSON(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/bind-uri/",
	"title": "Bind Uri",
	"tags": [],
	"description": "",
	"content": "See the detail information.\npackage main import \u0026#34;github.com/gin-gonic/gin\u0026#34; type Person struct { ID string `uri:\u0026#34;id\u0026#34; binding:\u0026#34;required,uuid\u0026#34;` Name string `uri:\u0026#34;name\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { route := gin.Default() route.GET(\u0026#34;/:name/:id\u0026#34;, func(c *gin.Context) { var person Person if err := c.ShouldBindUri(\u0026amp;person); err != nil { c.JSON(400, gin.H{\u0026#34;msg\u0026#34;: err}) return } c.JSON(200, gin.H{\u0026#34;name\u0026#34;: person.Name, \u0026#34;uuid\u0026#34;: person.ID}) }) route.Run(\u0026#34;:8088\u0026#34;) } Test it with:\n$ curl -v localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3 $ curl -v localhost:8088/thinkerou/not-uuid"
},
{
	"uri": "https://gin-gonic.com/api-example/bind-form-data-request-with-custom-struct/",
	"title": "Bind form-data request with custom struct",
	"tags": [],
	"description": "",
	"content": "The follow example using custom struct:\ntype StructA struct { FieldA string `form:\u0026#34;field_a\u0026#34;` } type StructB struct { NestedStruct StructA FieldB string `form:\u0026#34;field_b\u0026#34;` } type StructC struct { NestedStructPointer *StructA FieldC string `form:\u0026#34;field_c\u0026#34;` } type StructD struct { NestedAnonyStruct struct { FieldX string `form:\u0026#34;field_x\u0026#34;` } FieldD string `form:\u0026#34;field_d\u0026#34;` } func GetDataB(c *gin.Context) { var b StructB c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;a\u0026#34;: b.NestedStruct, \u0026#34;b\u0026#34;: b.FieldB, }) } func GetDataC(c *gin.Context) { var b StructC c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;a\u0026#34;: b.NestedStructPointer, \u0026#34;c\u0026#34;: b.FieldC, }) } func GetDataD(c *gin.Context) { var b StructD c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;x\u0026#34;: b.NestedAnonyStruct, \u0026#34;d\u0026#34;: b.FieldD, }) } func main() { r := gin.Default() r.GET(\u0026#34;/getb\u0026#34;, GetDataB) r.GET(\u0026#34;/getc\u0026#34;, GetDataC) r.GET(\u0026#34;/getd\u0026#34;, GetDataD) r.Run() } Using the command curl command result:\n$ curl \u0026quot;http://localhost:8080/getb?field_a=hello\u0026amp;field_b=world\u0026quot; {\u0026quot;a\u0026quot;:{\u0026quot;FieldA\u0026quot;:\u0026quot;hello\u0026quot;},\u0026quot;b\u0026quot;:\u0026quot;world\u0026quot;} $ curl \u0026quot;http://localhost:8080/getc?field_a=hello\u0026amp;field_c=world\u0026quot; {\u0026quot;a\u0026quot;:{\u0026quot;FieldA\u0026quot;:\u0026quot;hello\u0026quot;},\u0026quot;c\u0026quot;:\u0026quot;world\u0026quot;} $ curl \u0026quot;http://localhost:8080/getd?field_x=hello\u0026amp;field_d=world\u0026quot; {\u0026quot;d\u0026quot;:\u0026quot;world\u0026quot;,\u0026quot;x\u0026quot;:{\u0026quot;FieldX\u0026quot;:\u0026quot;hello\u0026quot;}}  NOTE: NOT support the follow style struct:\ntype StructX struct { X struct {} `form:\u0026#34;name_x\u0026#34;` // HERE have form } type StructY struct { Y StructX `form:\u0026#34;name_y\u0026#34;` // HERE have form } type StructZ struct { Z *StructZ `form:\u0026#34;name_z\u0026#34;` // HERE have form } In a word, only support nested custom struct which have no form now.\n"
},
{
	"uri": "https://gin-gonic.com/api-example/bind-html-checkbox/",
	"title": "Bind html checkboxes",
	"tags": [],
	"description": "",
	"content": "See the detail information\nmain.go\n... type myForm struct { Colors []string `form:\u0026#34;colors[]\u0026#34;` } ... func formHandler(c *gin.Context) { var fakeForm myForm c.ShouldBind(\u0026amp;fakeForm) c.JSON(200, gin.H{\u0026#34;color\u0026#34;: fakeForm.Colors}) } ... form.html\n\u0026lt;form action=\u0026#34;/\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Check some colors\u0026lt;/p\u0026gt; \u0026lt;label for=\u0026#34;red\u0026#34;\u0026gt;Red\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;red\u0026#34; id=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;green\u0026#34;\u0026gt;Green\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;green\u0026#34; id=\u0026#34;green\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;blue\u0026#34;\u0026gt;Blue\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;blue\u0026#34; id=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; result:\n{\u0026#34;color\u0026#34;:[\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;]}"
},
{
	"uri": "https://gin-gonic.com/api-example/bind-query-or-post/",
	"title": "Bind query string or post data",
	"tags": [],
	"description": "",
	"content": "See the detail information.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Person struct { Name string `form:\u0026#34;name\u0026#34;` Address string `form:\u0026#34;address\u0026#34;` Birthday time.Time `form:\u0026#34;birthday\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34; time_utc:\u0026#34;1\u0026#34;` } func main() { route := gin.Default() route.GET(\u0026#34;/testing\u0026#34;, startPage) route.Run(\u0026#34;:8085\u0026#34;) } func startPage(c *gin.Context) { var person Person // If `GET`, only `Form` binding engine (`query`) used. \t// If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`). \t// See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48 \tif c.ShouldBind(\u0026amp;person) == nil { log.Println(person.Name) log.Println(person.Address) log.Println(person.Birthday) } c.String(200, \u0026#34;Success\u0026#34;) } Test it with:\n$ curl -X GET \u0026#34;localhost:8085/testing?name=appleboy\u0026amp;address=xyz\u0026amp;birthday=1992-03-15\u0026#34;"
},
{
	"uri": "https://gin-gonic.com/api-example/bind-single-binary-with-template/",
	"title": "Build a single binary with templates",
	"tags": [],
	"description": "",
	"content": "You can build a server into a single binary containing templates by using go-assets.\nfunc main() { r := gin.New() t, err := loadTemplate() if err != nil { panic(err) } r.SetHTMLTemplate(t) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;/html/index.tmpl\u0026#34;,nil) }) r.Run(\u0026#34;:8080\u0026#34;) } // loadTemplate loads templates embedded by go-assets-builder func loadTemplate() (*template.Template, error) { t := template.New(\u0026#34;\u0026#34;) for name, file := range Assets.Files { if file.IsDir() || !strings.HasSuffix(name, \u0026#34;.tmpl\u0026#34;) { continue } h, err := ioutil.ReadAll(file) if err != nil { return nil, err } t, err = t.New(name).Parse(string(h)) if err != nil { return nil, err } } return t, nil } See a complete example in the examples/assets-in-binary directory.\n"
},
{
	"uri": "https://gin-gonic.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gin-gonic.com/api-example/custom-http-config/",
	"title": "Custom HTTP configuration",
	"tags": [],
	"description": "",
	"content": "Use http.ListenAndServe() directly, like this:\nfunc main() { router := gin.Default() http.ListenAndServe(\u0026#34;:8080\u0026#34;, router) } or\nfunc main() { router := gin.Default() s := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u0026lt;\u0026lt; 20, } s.ListenAndServe() }"
},
{
	"uri": "https://gin-gonic.com/api-example/custom-middleware/",
	"title": "Custom Middleware",
	"tags": [],
	"description": "",
	"content": "func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // Set example variable \tc.Set(\u0026#34;example\u0026#34;, \u0026#34;12345\u0026#34;) // before request  c.Next() // after request \tlatency := time.Since(t) log.Print(latency) // access the status we are sending \tstatus := c.Writer.Status() log.Println(status) } } func main() { r := gin.New() r.Use(Logger()) r.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { example := c.MustGet(\u0026#34;example\u0026#34;).(string) // it would print: \u0026#34;12345\u0026#34; \tlog.Println(example) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/custom-validators/",
	"title": "Custom validators",
	"tags": [],
	"description": "",
	"content": "It is also possible to register custom validators. See the example code.\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/gin-gonic/gin/binding\u0026#34; \u0026#34;gopkg.in/go-playground/validator.v8\u0026#34; ) // Booking contains binded and validated data. type Booking struct { CheckIn time.Time `form:\u0026#34;check_in\u0026#34; binding:\u0026#34;required,bookabledate\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34;` CheckOut time.Time `form:\u0026#34;check_out\u0026#34; binding:\u0026#34;required,gtfield=CheckIn\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34;` } func bookableDate( v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string, ) bool { if date, ok := field.Interface().(time.Time); ok { today := time.Now() if today.Year() \u0026gt; date.Year() || today.YearDay() \u0026gt; date.YearDay() { return false } } return true } func main() { route := gin.Default() if v, ok := binding.Validator.Engine().(*validator.Validate); ok { v.RegisterValidation(\u0026#34;bookabledate\u0026#34;, bookableDate) } route.GET(\u0026#34;/bookable\u0026#34;, getBookable) route.Run(\u0026#34;:8085\u0026#34;) } func getBookable(c *gin.Context) { var b Booking if err := c.ShouldBindWith(\u0026amp;b, binding.Query); err == nil { c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;Booking dates are valid!\u0026#34;}) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }$ curl \u0026#34;localhost:8085/bookable?check_in=2018-04-16\u0026amp;check_out=2018-04-17\u0026#34; {\u0026#34;message\u0026#34;:\u0026#34;Booking dates are valid!\u0026#34;} $ curl \u0026#34;localhost:8085/bookable?check_in=2018-03-08\u0026amp;check_out=2018-03-09\u0026#34; {\u0026#34;error\u0026#34;:\u0026#34;Key: \u0026#39;Booking.CheckIn\u0026#39; Error:Field validation for \u0026#39;CheckIn\u0026#39; failed on the \u0026#39;bookabledate\u0026#39; tag\u0026#34;} Struct level validations can also be registered this way. See the struct-lvl-validation example to learn more.\n"
},
{
	"uri": "https://gin-gonic.com/api-example/define-format-for-the-log-of-routes/",
	"title": "Define format for the log of routes",
	"tags": [],
	"description": "",
	"content": "The default log of routes is:\n[GIN-debug] POST /foo --\u0026gt; main.main.func1 (3 handlers) [GIN-debug] GET /bar --\u0026gt; main.main.func2 (3 handlers) [GIN-debug] GET /status --\u0026gt; main.main.func3 (3 handlers)  If you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with gin.DebugPrintRouteFunc. In the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.\nimport ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) { log.Printf(\u0026#34;endpoint %v %v %v %v\\n\u0026#34;, httpMethod, absolutePath, handlerName, nuHandlers) } r.POST(\u0026#34;/foo\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;foo\u0026#34;) }) r.GET(\u0026#34;/bar\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;bar\u0026#34;) }) r.GET(\u0026#34;/status\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;ok\u0026#34;) }) // Listen and Server in http://0.0.0.0:8080 \tr.Run() }"
},
{
	"uri": "https://gin-gonic.com/api-example/goroutines-inside-a-middleware/",
	"title": "Goroutines inside a middleware",
	"tags": [],
	"description": "",
	"content": "When starting new Goroutines inside a middleware or handler, you SHOULD NOT use the original context inside it, you have to use a read-only copy.\nfunc main() { r := gin.Default() r.GET(\u0026#34;/long_async\u0026#34;, func(c *gin.Context) { // create copy to be used inside the goroutine \tcCp := c.Copy() go func() { // simulate a long task with time.Sleep(). 5 seconds \ttime.Sleep(5 * time.Second) // note that you are using the copied context \u0026#34;cCp\u0026#34;, IMPORTANT \tlog.Println(\u0026#34;Done! in path \u0026#34; + cCp.Request.URL.Path) }() }) r.GET(\u0026#34;/long_sync\u0026#34;, func(c *gin.Context) { // simulate a long task with time.Sleep(). 5 seconds \ttime.Sleep(5 * time.Second) // since we are NOT using a goroutine, we do not have to copy the context \tlog.Println(\u0026#34;Done! in path \u0026#34; + c.Request.URL.Path) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/graceful-restart-or-stop/",
	"title": "Graceful restart or stop",
	"tags": [],
	"description": "",
	"content": "Do you want to graceful restart or stop your web server? There are some ways this can be done.\nWe can use fvbock/endless to replace the default ListenAndServe. Refer issue #296 for more details.\nrouter := gin.Default() router.GET(\u0026#34;/\u0026#34;, handler) // [...] endless.ListenAndServe(\u0026#34;:4242\u0026#34;, router) An alternative to endless:\n manners: A polite Go HTTP server that shuts down gracefully. graceful: Graceful is a Go package enabling graceful shutdown of an http.Handler server. grace: Graceful restart \u0026amp; zero downtime deploy for Go servers.  If you are using Go 1.8, you may not need to use this library! Consider using http.Server\u0026rsquo;s built-in Shutdown() method for graceful shutdowns. See the full graceful-shutdown example with gin.\n// +build go1.8  package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { router := gin.Default() router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { time.Sleep(5 * time.Second) c.String(http.StatusOK, \u0026#34;Welcome Gin Server\u0026#34;) }) srv := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router, } go func() { // service connections \tif err := srv.ListenAndServe(); err != nil \u0026amp;\u0026amp; err != http.ErrServerClosed { log.Fatalf(\u0026#34;listen: %s\\n\u0026#34;, err) } }() // Wait for interrupt signal to gracefully shutdown the server with \t// a timeout of 5 seconds. \tquit := make(chan os.Signal) signal.Notify(quit, os.Interrupt) \u0026lt;-quit log.Println(\u0026#34;Shutdown Server ...\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() if err := srv.Shutdown(ctx); err != nil { log.Fatal(\u0026#34;Server Shutdown:\u0026#34;, err) } log.Println(\u0026#34;Server exiting\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/grouping-routes/",
	"title": "Grouping routes",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() // Simple group: v1 \tv1 := router.Group(\u0026#34;/v1\u0026#34;) { v1.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v1.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v1.POST(\u0026#34;/read\u0026#34;, readEndpoint) } // Simple group: v2 \tv2 := router.Group(\u0026#34;/v2\u0026#34;) { v2.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v2.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v2.POST(\u0026#34;/read\u0026#34;, readEndpoint) } router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/html-rendering/",
	"title": "HTML rendering",
	"tags": [],
	"description": "",
	"content": " Using LoadHTMLGlob() or LoadHTMLFiles()\nfunc main() { router := gin.Default() router.LoadHTMLGlob(\u0026#34;templates/*\u0026#34;) //router.LoadHTMLFiles(\u0026#34;templates/template1.html\u0026#34;, \u0026#34;templates/template2.html\u0026#34;) \trouter.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Main website\u0026#34;, }) }) router.Run(\u0026#34;:8080\u0026#34;) } templates/index.tmpl\n\u0026lt;html\u0026gt; \u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;/html\u0026gt; Using templates with same name in different directories\nfunc main() { router := gin.Default() router.LoadHTMLGlob(\u0026#34;templates/**/*\u0026#34;) router.GET(\u0026#34;/posts/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;posts/index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Posts\u0026#34;, }) }) router.GET(\u0026#34;/users/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;users/index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Users\u0026#34;, }) }) router.Run(\u0026#34;:8080\u0026#34;) } templates/posts/index.tmpl\n{{ define \u0026#34;posts/index.tmpl\u0026#34; }} \u0026lt;html\u0026gt;\u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Using posts/index.tmpl\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; {{ end }} templates/users/index.tmpl\n{{ define \u0026#34;users/index.tmpl\u0026#34; }} \u0026lt;html\u0026gt;\u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Using users/index.tmpl\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; {{ end }} Custom Template renderer You can also use your own html template render\nimport \u0026#34;html/template\u0026#34; func main() { router := gin.Default() html := template.Must(template.ParseFiles(\u0026#34;file1\u0026#34;, \u0026#34;file2\u0026#34;)) router.SetHTMLTemplate(html) router.Run(\u0026#34;:8080\u0026#34;) } Custom Delimiters You may use custom delims\nr := gin.Default() r.Delims(\u0026#34;{[{\u0026#34;, \u0026#34;}]}\u0026#34;) r.LoadHTMLGlob(\u0026#34;/path/to/templates\u0026#34;) Custom Template Funcs See the detail example code.\nmain.go\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func formatAsDate(t time.Time) string { year, month, day := t.Date() return fmt.Sprintf(\u0026#34;%d%02d/%02d\u0026#34;, year, month, day) } func main() { router := gin.Default() router.Delims(\u0026#34;{[{\u0026#34;, \u0026#34;}]}\u0026#34;) router.SetFuncMap(template.FuncMap{ \u0026#34;formatAsDate\u0026#34;: formatAsDate, }) router.LoadHTMLFiles(\u0026#34;./testdata/template/raw.tmpl\u0026#34;) router.GET(\u0026#34;/raw\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;raw.tmpl\u0026#34;, map[string]interface{}{ \u0026#34;now\u0026#34;: time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC), }) }) router.Run(\u0026#34;:8080\u0026#34;) } raw.tmpl\nDate: {[{.now | formatAsDate}]} Result:\nDate: 2017/07/01"
},
{
	"uri": "https://gin-gonic.com/api-example/http2-server-push/",
	"title": "HTTP2 server push",
	"tags": [],
	"description": "",
	"content": "http.Pusher is supported only go1.8+. See the golang blog for detail information.\npackage main import ( \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) var html = template.Must(template.New(\u0026#34;https\u0026#34;).Parse(` \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Https Test\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/assets/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;color:red;\u0026#34;\u0026gt;Welcome, Ginner!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; `)) func main() { r := gin.Default() r.Static(\u0026#34;/assets\u0026#34;, \u0026#34;./assets\u0026#34;) r.SetHTMLTemplate(html) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { if pusher := c.Writer.Pusher(); pusher != nil { // use pusher.Push() to do server push \tif err := pusher.Push(\u0026#34;/assets/app.js\u0026#34;, nil); err != nil { log.Printf(\u0026#34;Failed to push: %v\u0026#34;, err) } } c.HTML(200, \u0026#34;https\u0026#34;, gin.H{ \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, }) }) // Listen and Server in https://127.0.0.1:8080 \tr.RunTLS(\u0026#34;:8080\u0026#34;, \u0026#34;./testdata/server.pem\u0026#34;, \u0026#34;./testdata/server.key\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/write-log/",
	"title": "How to write log file",
	"tags": [],
	"description": "",
	"content": "func main() { // Disable Console Color, you don\u0026#39;t need console color when writing the logs to file.  gin.DisableConsoleColor() // Logging to a file.  f, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(f) // Use the following code if you need to write the logs to file and console at the same time.  // gin.DefaultWriter = io.MultiWriter(f, os.Stdout)  router := gin.Default() router.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/jsonp/",
	"title": "JSONP",
	"tags": [],
	"description": "",
	"content": "Using JSONP to request data from a server in a different domain. Add callback to response body if the query parameter callback exists.\nfunc main() { r := gin.Default() r.GET(\u0026#34;/JSONP?callback=x\u0026#34;, func(c *gin.Context) { data := map[string]interface{}{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, } //callback is x \t// Will output : x({\\\u0026#34;foo\\\u0026#34;:\\\u0026#34;bar\\\u0026#34;}) \tc.JSONP(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/map-as-querystring-or-postform/",
	"title": "Map as querystring or postform parameters",
	"tags": [],
	"description": "",
	"content": "POST /post?ids[a]=1234\u0026amp;ids[b]=hello HTTP/1.1 Content-Type: application/x-www-form-urlencoded names[first]=thinkerou\u0026amp;names[second]=tianoufunc main() { router := gin.Default() router.POST(\u0026#34;/post\u0026#34;, func(c *gin.Context) { ids := c.QueryMap(\u0026#34;ids\u0026#34;) names := c.PostFormMap(\u0026#34;names\u0026#34;) fmt.Printf(\u0026#34;ids: %v; names: %v\u0026#34;, ids, names) }) router.Run(\u0026#34;:8080\u0026#34;) }ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou]"
},
{
	"uri": "https://gin-gonic.com/api-example/binding-and-validation/",
	"title": "Model binding and validation",
	"tags": [],
	"description": "",
	"content": " To bind a request body into a type, use model binding. We currently support binding of JSON, XML, YAML and standard form values (foo=bar\u0026amp;boo=baz).\nGin uses go-playground/validator.v8 for validation. Check the full docs on tags usage here.\nNote that you need to set the corresponding binding tag on all fields you want to bind. For example, when binding from JSON, set json:\u0026quot;fieldname\u0026quot;.\nAlso, Gin provides two sets of methods for binding: - Type - Must bind - Methods - Bind, BindJSON, BindXML, BindQuery, BindYAML - Behavior - These methods use MustBindWith under the hood. If there is a binding error, the request is aborted with c.AbortWithError(400, err).SetType(ErrorTypeBind). This sets the response status code to 400 and the Content-Type header is set to text/plain; charset=utf-8. Note that if you try to set the response code after this, it will result in a warning [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422. If you wish to have greater control over the behavior, consider using the ShouldBind equivalent method. - Type - Should bind - Methods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML - Behavior - These methods use ShouldBindWith under the hood. If there is a binding error, the error is returned and it is the developer\u0026rsquo;s responsibility to handle the request and error appropriately.\nWhen using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use MustBindWith or ShouldBindWith.\nYou can also specify that specific fields are required. If a field is decorated with binding:\u0026quot;required\u0026quot; and has a empty value when binding, an error will be returned.\n// Binding from JSON type Login struct { User string `form:\u0026#34;user\u0026#34; json:\u0026#34;user\u0026#34; xml:\u0026#34;user\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `form:\u0026#34;password\u0026#34; json:\u0026#34;password\u0026#34; xml:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { router := gin.Default() // Example for binding JSON ({\u0026#34;user\u0026#34;: \u0026#34;manu\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123\u0026#34;}) \trouter.POST(\u0026#34;/loginJSON\u0026#34;, func(c *gin.Context) { var json Login if err := c.ShouldBindJSON(\u0026amp;json); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if json.User != \u0026#34;manu\u0026#34; || json.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Example for binding XML ( \t//\t\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \t//\t\u0026lt;root\u0026gt; \t//\t\u0026lt;user\u0026gt;user\u0026lt;/user\u0026gt; \t//\t\u0026lt;password\u0026gt;123\u0026lt;/user\u0026gt; \t//\t\u0026lt;/root\u0026gt;) \trouter.POST(\u0026#34;/loginXML\u0026#34;, func(c *gin.Context) { var xml Login if err := c.ShouldBindXML(\u0026amp;xml); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if xml.User != \u0026#34;manu\u0026#34; || xml.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Example for binding a HTML form (user=manu\u0026amp;password=123) \trouter.POST(\u0026#34;/loginForm\u0026#34;, func(c *gin.Context) { var form Login // This will infer what binder to use depending on the content-type header. \tif err := c.ShouldBind(\u0026amp;form); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if form.User != \u0026#34;manu\u0026#34; || form.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Listen and serve on 0.0.0.0:8080 \trouter.Run(\u0026#34;:8080\u0026#34;) } Sample request $ curl -v -X POST \\  http://localhost:8080/loginJSON \\  -H \u0026#39;content-type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;user\u0026#34;: \u0026#34;manu\u0026#34; }\u0026#39; \u0026gt; POST /loginJSON HTTP/1.1 \u0026gt; Host: localhost:8080 \u0026gt; User-Agent: curl/7.51.0 \u0026gt; Accept: */* \u0026gt; content-type: application/json \u0026gt; Content-Length: 18 \u0026gt; * upload completely sent off: 18 out of 18 bytes \u0026lt; HTTP/1.1 400 Bad Request \u0026lt; Content-Type: application/json; charset=utf-8 \u0026lt; Date: Fri, 04 Aug 2017 03:51:31 GMT \u0026lt; Content-Length: 100 \u0026lt; {\u0026#34;error\u0026#34;:\u0026#34;Key: \u0026#39;Login.Password\u0026#39; Error:Field validation for \u0026#39;Password\u0026#39; failed on the \u0026#39;required\u0026#39; tag\u0026#34;} Skip validate When running the above example using the above the curl command, it returns error. Because the example use binding:\u0026quot;required\u0026quot; for Password. If use binding:\u0026quot;-\u0026quot; for Password, then it will not return error when running the above example again.\n"
},
{
	"uri": "https://gin-gonic.com/api-example/multipart-urlencoded-binding/",
	"title": "Multipart/Urlencoded binding",
	"tags": [],
	"description": "",
	"content": "package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type LoginForm struct { User string `form:\u0026#34;user\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `form:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { router := gin.Default() router.POST(\u0026#34;/login\u0026#34;, func(c *gin.Context) { // you can bind multipart form with explicit binding declaration: \t// c.ShouldBindWith(\u0026amp;form, binding.Form) \t// or you can simply use autobinding with ShouldBind method: \tvar form LoginForm // in this case proper binding will be automatically selected \tif c.ShouldBind(\u0026amp;form) == nil { if form.User == \u0026#34;user\u0026#34; \u0026amp;\u0026amp; form.Password == \u0026#34;password\u0026#34; { c.JSON(200, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) } else { c.JSON(401, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) } } }) router.Run(\u0026#34;:8080\u0026#34;) } Test it with:\n$ curl -v --form user=user --form password=password http://localhost:8080/login"
},
{
	"uri": "https://gin-gonic.com/api-example/multipart-urlencoded-form/",
	"title": "Multipart/Urlencoded form",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() router.POST(\u0026#34;/form_post\u0026#34;, func(c *gin.Context) { message := c.PostForm(\u0026#34;message\u0026#34;) nick := c.DefaultPostForm(\u0026#34;nick\u0026#34;, \u0026#34;anonymous\u0026#34;) c.JSON(200, gin.H{ \u0026#34;status\u0026#34;: \u0026#34;posted\u0026#34;, \u0026#34;message\u0026#34;: message, \u0026#34;nick\u0026#34;: nick, }) }) router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/upload-file/multiple-file/",
	"title": "Multiple files",
	"tags": [],
	"description": "",
	"content": "See the detail example code.\nfunc main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) \t// router.MaxMultipartMemory = 8 \u0026lt;\u0026lt; 20 // 8 MiB \trouter.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { // Multipart form \tform, _ := c.MultipartForm() files := form.File[\u0026#34;upload[]\u0026#34;] for _, file := range files { log.Println(file.Filename) // Upload the file to specific dst. \t// c.SaveUploadedFile(file, dst) \t} c.String(http.StatusOK, fmt.Sprintf(\u0026#34;%d files uploaded!\u0026#34;, len(files))) }) router.Run(\u0026#34;:8080\u0026#34;) } How to curl:\ncurl -X POST http://localhost:8080/upload \\  -F \u0026#34;upload[]=@/Users/appleboy/test1.zip\u0026#34; \\  -F \u0026#34;upload[]=@/Users/appleboy/test2.zip\u0026#34; \\  -H \u0026#34;Content-Type: multipart/form-data\u0026#34;"
},
{
	"uri": "https://gin-gonic.com/api-example/multiple-template/",
	"title": "Multitemplate",
	"tags": [],
	"description": "",
	"content": "Gin allow by default use only one html.Template. Check a multitemplate render for using features like go 1.6 block template.\n"
},
{
	"uri": "https://gin-gonic.com/api-example/only-bind-query-string/",
	"title": "Only bind query string",
	"tags": [],
	"description": "",
	"content": "ShouldBindQuery function only binds the query params and not the post data. See the detail information.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Person struct { Name string `form:\u0026#34;name\u0026#34;` Address string `form:\u0026#34;address\u0026#34;` } func main() { route := gin.Default() route.Any(\u0026#34;/testing\u0026#34;, startPage) route.Run(\u0026#34;:8085\u0026#34;) } func startPage(c *gin.Context) { var person Person if c.ShouldBindQuery(\u0026amp;person) == nil { log.Println(\u0026#34;====== Only Bind By Query String ======\u0026#34;) log.Println(person.Name) log.Println(person.Address) } c.String(200, \u0026#34;Success\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/param-in-path/",
	"title": "Parameters in path",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() // This handler will match /user/john but will not match /user/ or /user \trouter.GET(\u0026#34;/user/:name\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) c.String(http.StatusOK, \u0026#34;Hello %s\u0026#34;, name) }) // However, this one will match /user/john/ and also /user/john/send \t// If no other routers match /user/john, it will redirect to /user/john/ \trouter.GET(\u0026#34;/user/:name/*action\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) action := c.Param(\u0026#34;action\u0026#34;) message := name + \u0026#34; is \u0026#34; + action c.String(http.StatusOK, message) }) router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/pure-json/",
	"title": "PureJSON",
	"tags": [],
	"description": "",
	"content": "Normally, JSON replaces special HTML characters with their unicode entities, e.g. \u0026lt; becomes \\u003c. If you want to encode such characters literally, you can use PureJSON instead. This feature is unavailable in Go 1.6 and lower.\nfunc main() { r := gin.Default() // Serves unicode entities \tr.GET(\u0026#34;/json\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;html\u0026#34;: \u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;, }) }) // Serves literal characters \tr.GET(\u0026#34;/purejson\u0026#34;, func(c *gin.Context) { c.PureJSON(200, gin.H{ \u0026#34;html\u0026#34;: \u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;, }) }) // listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/query-and-post-form/",
	"title": "Query and post form",
	"tags": [],
	"description": "",
	"content": "POST /post?id=1234\u0026amp;page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=manu\u0026amp;message=this_is_greatfunc main() { router := gin.Default() router.POST(\u0026#34;/post\u0026#34;, func(c *gin.Context) { id := c.Query(\u0026#34;id\u0026#34;) page := c.DefaultQuery(\u0026#34;page\u0026#34;, \u0026#34;0\u0026#34;) name := c.PostForm(\u0026#34;name\u0026#34;) message := c.PostForm(\u0026#34;message\u0026#34;) fmt.Printf(\u0026#34;id: %s; page: %s; name: %s; message: %s\u0026#34;, id, page, name, message) }) router.Run(\u0026#34;:8080\u0026#34;) }id: 1234; page: 1; name: manu; message: this_is_great"
},
{
	"uri": "https://gin-gonic.com/api-example/querystring-param/",
	"title": "Query string parameters",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() // Query string parameters are parsed using the existing underlying request object. \t// The request responds to a url matching: /welcome?firstname=Jane\u0026amp;lastname=Doe \trouter.GET(\u0026#34;/welcome\u0026#34;, func(c *gin.Context) { firstname := c.DefaultQuery(\u0026#34;firstname\u0026#34;, \u0026#34;Guest\u0026#34;) lastname := c.Query(\u0026#34;lastname\u0026#34;) // shortcut for c.Request.URL.Query().Get(\u0026#34;lastname\u0026#34;)  c.String(http.StatusOK, \u0026#34;Hello %s %s\u0026#34;, firstname, lastname) }) router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/redirects/",
	"title": "Redirects",
	"tags": [],
	"description": "",
	"content": "Issuing a HTTP redirect is easy. Both internal and external locations are supported.\nr.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \u0026#34;http://www.google.com/\u0026#34;) }) Issuing a Router redirect, use HandleContext like below.\nr.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.Request.URL.Path = \u0026#34;/test2\u0026#34; r.HandleContext(c) }) r.GET(\u0026#34;/test2\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;}) })"
},
{
	"uri": "https://gin-gonic.com/api-example/run-multiple-service/",
	"title": "Run multiple service",
	"tags": [],
	"description": "",
	"content": "See the question and try the following example:\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) var ( g errgroup.Group ) func router01() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: http.StatusOK, \u0026#34;error\u0026#34;: \u0026#34;Welcome server 01\u0026#34;, }, ) }) return e } func router02() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: http.StatusOK, \u0026#34;error\u0026#34;: \u0026#34;Welcome server 02\u0026#34;, }, ) }) return e } func main() { server01 := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router01(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server02 := \u0026amp;http.Server{ Addr: \u0026#34;:8081\u0026#34;, Handler: router02(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } g.Go(func() error { return server01.ListenAndServe() }) g.Go(func() error { return server02.ListenAndServe() }) if err := g.Wait(); err != nil { log.Fatal(err) } }"
},
{
	"uri": "https://gin-gonic.com/api-example/secure-json/",
	"title": "SecureJSON",
	"tags": [],
	"description": "",
	"content": "Using SecureJSON to prevent json hijacking. Default prepends \u0026quot;while(1),\u0026quot; to response body if the given struct is array values.\nfunc main() { r := gin.Default() // You can also use your own secure json prefix \t// r.SecureJsonPrefix(\u0026#34;)]}\u0026#39;,\\n\u0026#34;)  r.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { names := []string{\u0026#34;lena\u0026#34;, \u0026#34;austin\u0026#34;, \u0026#34;foo\u0026#34;} // Will output : while(1);[\u0026#34;lena\u0026#34;,\u0026#34;austin\u0026#34;,\u0026#34;foo\u0026#34;] \tc.SecureJSON(http.StatusOK, names) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/serving-data-from-reader/",
	"title": "Serving data from reader",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() router.GET(\u0026#34;/someDataFromReader\u0026#34;, func(c *gin.Context) { response, err := http.Get(\u0026#34;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\u0026#34;) if err != nil || response.StatusCode != http.StatusOK { c.Status(http.StatusServiceUnavailable) return } reader := response.Body contentLength := response.ContentLength contentType := response.Header.Get(\u0026#34;Content-Type\u0026#34;) extraHeaders := map[string]string{ \u0026#34;Content-Disposition\u0026#34;: `attachment; filename=\u0026#34;gopher.png\u0026#34;`, } c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders) }) router.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/serving-static-files/",
	"title": "Serving static files",
	"tags": [],
	"description": "",
	"content": "func main() { router := gin.Default() router.Static(\u0026#34;/assets\u0026#34;, \u0026#34;./assets\u0026#34;) router.StaticFS(\u0026#34;/more_static\u0026#34;, http.Dir(\u0026#34;my_file_system\u0026#34;)) router.StaticFile(\u0026#34;/favicon.ico\u0026#34;, \u0026#34;./resources/favicon.ico\u0026#34;) // Listen and serve on 0.0.0.0:8080 \trouter.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/cookie/",
	"title": "Set and get a cookie",
	"tags": [],
	"description": "",
	"content": "import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { router := gin.Default() router.GET(\u0026#34;/cookie\u0026#34;, func(c *gin.Context) { cookie, err := c.Cookie(\u0026#34;gin_cookie\u0026#34;) if err != nil { cookie = \u0026#34;NotSet\u0026#34; c.SetCookie(\u0026#34;gin_cookie\u0026#34;, \u0026#34;test\u0026#34;, 3600, \u0026#34;/\u0026#34;, \u0026#34;localhost\u0026#34;, false, true) } fmt.Printf(\u0026#34;Cookie value: %s \\n\u0026#34;, cookie) }) router.Run() }"
},
{
	"uri": "https://gin-gonic.com/api-example/upload-file/single-file/",
	"title": "Single file",
	"tags": [],
	"description": "",
	"content": "References issue #774 and detail example code.\nfunc main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) \t// router.MaxMultipartMemory = 8 \u0026lt;\u0026lt; 20 // 8 MiB \trouter.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { // single file \tfile, _ := c.FormFile(\u0026#34;file\u0026#34;) log.Println(file.Filename) // Upload the file to specific dst. \t// c.SaveUploadedFile(file, dst)  c.String(http.StatusOK, fmt.Sprintf(\u0026#34;\u0026#39;%s\u0026#39; uploaded!\u0026#34;, file.Filename)) }) router.Run(\u0026#34;:8080\u0026#34;) } How to curl:\ncurl -X POST http://localhost:8080/upload \\  -F \u0026#34;file=@/Users/appleboy/test.zip\u0026#34; \\  -H \u0026#34;Content-Type: multipart/form-data\u0026#34;"
},
{
	"uri": "https://gin-gonic.com/api-example/support-lets-encrypt/",
	"title": "Support Let&#39;s Encrypt",
	"tags": [],
	"description": "",
	"content": "example for 1-line LetsEncrypt HTTPS servers.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/autotls\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() // Ping handler \tr.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) log.Fatal(autotls.Run(r, \u0026#34;example1.com\u0026#34;, \u0026#34;example2.com\u0026#34;)) } example for custom autocert manager.\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/autotls\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;golang.org/x/crypto/acme/autocert\u0026#34; ) func main() { r := gin.Default() // Ping handler \tr.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) m := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(\u0026#34;example1.com\u0026#34;, \u0026#34;example2.com\u0026#34;), Cache: autocert.DirCache(\u0026#34;/var/www/.cache\u0026#34;), } log.Fatal(autotls.RunWithManager(r, \u0026amp;m)) }"
},
{
	"uri": "https://gin-gonic.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gin-gonic.com/api-example/bind-body-into-dirrerent-structs/",
	"title": "Try to bind body into different structs",
	"tags": [],
	"description": "",
	"content": "The normal methods for binding request body consumes c.Request.Body and they cannot be called multiple times.\ntype formA struct { Foo string `json:\u0026#34;foo\u0026#34; xml:\u0026#34;foo\u0026#34; binding:\u0026#34;required\u0026#34;` } type formB struct { Bar string `json:\u0026#34;bar\u0026#34; xml:\u0026#34;bar\u0026#34; binding:\u0026#34;required\u0026#34;` } func SomeHandler(c *gin.Context) { objA := formA{} objB := formB{} // This c.ShouldBind consumes c.Request.Body and it cannot be reused.  if errA := c.ShouldBind(\u0026amp;objA); errA == nil { c.String(http.StatusOK, `the body should be formA`) // Always an error is occurred by this because c.Request.Body is EOF now.  } else if errB := c.ShouldBind(\u0026amp;objB); errB == nil { c.String(http.StatusOK, `the body should be formB`) } else { ... } } For this, you can use c.ShouldBindBodyWith.\nfunc SomeHandler(c *gin.Context) { objA := formA{} objB := formB{} // This reads c.Request.Body and stores the result into the context.  if errA := c.ShouldBindBodyWith(\u0026amp;objA, binding.JSON); errA == nil { c.String(http.StatusOK, `the body should be formA`) // At this time, it reuses body stored in the context.  } else if errB := c.ShouldBindBodyWith(\u0026amp;objB, binding.JSON); errB == nil { c.String(http.StatusOK, `the body should be formB JSON`) // And it can accepts other formats  } else if errB2 := c.ShouldBindBodyWith(\u0026amp;objB, binding.XML); errB2 == nil { c.String(http.StatusOK, `the body should be formB XML`) } else { ... } }  c.ShouldBindBodyWith stores body into the context before binding. This has a slight impact to performance, so you should not use this method if you are enough to call binding at once. This feature is only needed for some formats \u0026ndash; JSON, XML, MsgPack, ProtoBuf. For other formats, Query, Form, FormPost, FormMultipart, can be called by c.ShouldBind() multiple times without any damage to performance (See #1341).  "
},
{
	"uri": "https://gin-gonic.com/api-example/upload-file/",
	"title": "Upload files",
	"tags": [],
	"description": "",
	"content": "The section lists upload file api usage.\n"
},
{
	"uri": "https://gin-gonic.com/api-example/using-basicauth-middleware/",
	"title": "Using BasicAuth middleware",
	"tags": [],
	"description": "",
	"content": "// simulate some private data var secrets = gin.H{ \u0026#34;foo\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;123433\u0026#34;}, \u0026#34;austin\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;austin@example.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;666\u0026#34;}, \u0026#34;lena\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;lena@guapa.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;523443\u0026#34;}, } func main() { r := gin.Default() // Group using gin.BasicAuth() middleware \t// gin.Accounts is a shortcut for map[string]string \tauthorized := r.Group(\u0026#34;/admin\u0026#34;, gin.BasicAuth(gin.Accounts{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;austin\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;lena\u0026#34;: \u0026#34;hello2\u0026#34;, \u0026#34;manu\u0026#34;: \u0026#34;4321\u0026#34;, })) // /admin/secrets endpoint \t// hit \u0026#34;localhost:8080/admin/secrets \tauthorized.GET(\u0026#34;/secrets\u0026#34;, func(c *gin.Context) { // get user, it was set by the BasicAuth middleware \tuser := c.MustGet(gin.AuthUserKey).(string) if secret, ok := secrets[user]; ok { c.JSON(http.StatusOK, gin.H{\u0026#34;user\u0026#34;: user, \u0026#34;secret\u0026#34;: secret}) } else { c.JSON(http.StatusOK, gin.H{\u0026#34;user\u0026#34;: user, \u0026#34;secret\u0026#34;: \u0026#34;NO SECRET :(\u0026#34;}) } }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/http-method/",
	"title": "Using HTTP method",
	"tags": [],
	"description": "",
	"content": "func main() { // Disable Console Color \t// gin.DisableConsoleColor()  // Creates a gin router with default middleware: \t// logger and recovery (crash-free) middleware \trouter := gin.Default() router.GET(\u0026#34;/someGet\u0026#34;, getting) router.POST(\u0026#34;/somePost\u0026#34;, posting) router.PUT(\u0026#34;/somePut\u0026#34;, putting) router.DELETE(\u0026#34;/someDelete\u0026#34;, deleting) router.PATCH(\u0026#34;/somePatch\u0026#34;, patching) router.HEAD(\u0026#34;/someHead\u0026#34;, head) router.OPTIONS(\u0026#34;/someOptions\u0026#34;, options) // By default it serves on :8080 unless a \t// PORT environment variable was defined. \trouter.Run() // router.Run(\u0026#34;:3000\u0026#34;) for a hard coded port }"
},
{
	"uri": "https://gin-gonic.com/api-example/using-middleware/",
	"title": "Using middleware",
	"tags": [],
	"description": "",
	"content": "func main() { // Creates a router without any middleware by default \tr := gin.New() // Global middleware \t// Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release. \t// By default gin.DefaultWriter = os.Stdout \tr.Use(gin.Logger()) // Recovery middleware recovers from any panics and writes a 500 if there was one. \tr.Use(gin.Recovery()) // Per route middleware, you can add as many as you desire. \tr.GET(\u0026#34;/benchmark\u0026#34;, MyBenchLogger(), benchEndpoint) // Authorization group \t// authorized := r.Group(\u0026#34;/\u0026#34;, AuthRequired()) \t// exactly the same as: \tauthorized := r.Group(\u0026#34;/\u0026#34;) // per group middleware! in this case we use the custom created \t// AuthRequired() middleware just in the \u0026#34;authorized\u0026#34; group. \tauthorized.Use(AuthRequired()) { authorized.POST(\u0026#34;/login\u0026#34;, loginEndpoint) authorized.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) authorized.POST(\u0026#34;/read\u0026#34;, readEndpoint) // nested group \ttesting := authorized.Group(\u0026#34;testing\u0026#34;) testing.GET(\u0026#34;/analytics\u0026#34;, analyticsEndpoint) } // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/api-example/without-middleware/",
	"title": "Without middleware by default",
	"tags": [],
	"description": "",
	"content": "Use\nr := gin.New() instead of\n// Default With the Logger and Recovery middleware already attached r := gin.Default()"
},
{
	"uri": "https://gin-gonic.com/api-example/rendering/",
	"title": "XML/JSON/YAML/ProtoBuf rendering",
	"tags": [],
	"description": "",
	"content": "func main() { r := gin.Default() // gin.H is a shortcut for map[string]interface{} \tr.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/moreJSON\u0026#34;, func(c *gin.Context) { // You also can use a struct \tvar msg struct { Name string `json:\u0026#34;user\u0026#34;` Message string Number int } msg.Name = \u0026#34;Lena\u0026#34; msg.Message = \u0026#34;hey\u0026#34; msg.Number = 123 // Note that msg.Name becomes \u0026#34;user\u0026#34; in the JSON \t// Will output : {\u0026#34;user\u0026#34;: \u0026#34;Lena\u0026#34;, \u0026#34;Message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;Number\u0026#34;: 123} \tc.JSON(http.StatusOK, msg) }) r.GET(\u0026#34;/someXML\u0026#34;, func(c *gin.Context) { c.XML(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/someYAML\u0026#34;, func(c *gin.Context) { c.YAML(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/someProtoBuf\u0026#34;, func(c *gin.Context) { reps := []int64{int64(1), int64(2)} label := \u0026#34;test\u0026#34; // The specific definition of protobuf is written in the testdata/protoexample file. \tdata := \u0026amp;protoexample.Test{ Label: \u0026amp;label, Reps: reps, } // Note that data becomes binary data in the response \t// Will output protoexample.Test protobuf serialized data \tc.ProtoBuf(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) }"
},
{
	"uri": "https://gin-gonic.com/cn/",
	"title": "中文文档",
	"tags": [],
	"description": "",
	"content": " Gin 是一个 Go (Golang) 语言框架。 它是一个拥有更好性能的 martini-like API 框架, 比 httprouter 的速度快了40倍. 如果你是性能和高效的追求者, 那么你会爱上 Gin.\nContents  安装 前提条件 快速启动 性能测试 Gin v1 稳定版 使用 jsoniter 构建 API 示例  GET,POST,PUT,PATCH,DELETE,OPTIONS 使用 获取路由参数 获取url查询参数 Multipart Urlencoded 表单 获取post表单数据（url带查询参数） 映射参数 表单参数 上传文件 路由组 默认初始化 Gin 使用中间件 如何记录日志 模型绑定和验证 自定义验证器 只绑定url查询参数 url查询参数绑定到struct（或POST表单数据） 绑定 HTML 复选框 Multipart Urlencoded 绑定 XML JSON YAML ProtoBuf 渲染 SecureJSON 静态文件服务 从读者服务数据 HTML 渲染 多模板 重定向 自定义中间件 使用 BasicAuth() 中间件 Goroutines 自定义 HTTP 配置 Let\u0026rsquo;s Encrypt 支持 使用 Gin 运行多个服务 优雅重启或停止 使用模板构建单个二进制文件 表单数据绑定到自定义结构体 将request body绑定到不同的结构体中 http2 server 推送 定义路由日志的格式  测试 用户  安装 要安装 Gin 软件包，需要先安装 Go 并设置 Go 工作区。\n 下载并安装 gin:  $ go get -u github.com/gin-gonic/gin  将 gin 引入到代码中:  import \u0026#34;github.com/gin-gonic/gin\u0026#34;  （可选）如果使用诸如http.StatusOK之类的常量，则需要引入 net/http 包。  import \u0026#34;net/http\u0026#34; 使用 Govendor 工具创建项目  go get govendor  $ go get github.com/kardianos/govendor 2.创建项目并且 cd 到项目目录中\n$ mkdir -p $GOPATH/src/github.com/myusername/project \u0026amp;\u0026amp; cd \u0026#34;$_\u0026#34;  使用 govendor 初始化项目,并且引入gin  $ govendor init $ govendor fetch github.com/gin-gonic/gin@v1.3  复制启动文件模板到项目目录中  $ curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go \u0026gt; main.go 5.启动项目\n$ go run main.go 前提条件 新版本的 Gin 需要 Go 1.6 或者更高版本，并且很快就会升级到 Go 1.7.\n快速启动 # assume the following codes in example.go file $ cat example.gopackage main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } # run example.go and visit 0.0.0.0:8080/ping on browser $ go run example.go  性能测试 Gin 使用自定义版本的 HttpRouter\n所有性能测试\n   Benchmark name (1) (2) (3) (4)     BenchmarkGin_GithubAll 30000 48375 0 0   BenchmarkAce_GithubAll 10000 134059 13792 167   BenchmarkBear_GithubAll 5000 534445 86448 943   BenchmarkBeego_GithubAll 3000 592444 74705 812   BenchmarkBone_GithubAll 200 6957308 698784 8453   BenchmarkDenco_GithubAll 10000 158819 20224 167   BenchmarkEcho_GithubAll 10000 154700 6496 203   BenchmarkGocraftWeb_GithubAll 3000 570806 131656 1686   BenchmarkGoji_GithubAll 2000 818034 56112 334   BenchmarkGojiv2_GithubAll 2000 1213973 274768 3712   BenchmarkGoJsonRest_GithubAll 2000 785796 134371 2737   BenchmarkGoRestful_GithubAll 300 5238188 689672 4519   BenchmarkGorillaMux_GithubAll 100 10257726 211840 2272   BenchmarkHttpRouter_GithubAll 20000 105414 13792 167   BenchmarkHttpTreeMux_GithubAll 10000 319934 65856 671   BenchmarkKocha_GithubAll 10000 209442 23304 843   BenchmarkLARS_GithubAll 20000 62565 0 0   BenchmarkMacaron_GithubAll 2000 1161270 204194 2000   BenchmarkMartini_GithubAll 200 9991713 226549 2325   BenchmarkPat_GithubAll 200 5590793 1499568 27435   BenchmarkPossum_GithubAll 10000 319768 84448 609   BenchmarkR2router_GithubAll 10000 305134 77328 979   BenchmarkRivet_GithubAll 10000 132134 16272 167   BenchmarkTango_GithubAll 3000 552754 63826 1618   BenchmarkTigerTonic_GithubAll 1000 1439483 239104 5374   BenchmarkTraffic_GithubAll 100 11383067 2659329 21848   BenchmarkVulcan_GithubAll 5000 394253 19894 609     (1): 在不断的时间内实现总重复，更高意味着更自信的结果 (2): 单次重复持续时间（ns / op），越低越好 (3): 堆内存（B / op），越低越好 (4): 每次重复的平均分配（allocs / op）越低越好  Gin v1 稳定版 零分配路由器。 仍然是最快的http路由器和框架。 完整的单元测试套件 对战测试 API冻结，新版本不会破坏您的代码。  使用 jsoniter 构建 Gin使用encoding/json作为默认的json包，但您可以通过其他标签的构建更改为jsoniter。\n$ go build -tags=jsoniter . API 示例 GET, POST, PUT, PATCH, DELETE , OPTIONS 使用 func main() { // Disable Console Color \t// gin.DisableConsoleColor()  // Creates a gin router with default middleware: \t// logger and recovery (crash-free) middleware \trouter := gin.Default() router.GET(\u0026#34;/someGet\u0026#34;, getting) router.POST(\u0026#34;/somePost\u0026#34;, posting) router.PUT(\u0026#34;/somePut\u0026#34;, putting) router.DELETE(\u0026#34;/someDelete\u0026#34;, deleting) router.PATCH(\u0026#34;/somePatch\u0026#34;, patching) router.HEAD(\u0026#34;/someHead\u0026#34;, head) router.OPTIONS(\u0026#34;/someOptions\u0026#34;, options) // By default it serves on :8080 unless a \t// PORT environment variable was defined. \trouter.Run() // router.Run(\u0026#34;:3000\u0026#34;) for a hard coded port } 获取路由参数 func main() { router := gin.Default() // This handler will match /user/john but will not match /user/ or /user \trouter.GET(\u0026#34;/user/:name\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) c.String(http.StatusOK, \u0026#34;Hello %s\u0026#34;, name) }) // However, this one will match /user/john/ and also /user/john/send \t// If no other routers match /user/john, it will redirect to /user/john/ \trouter.GET(\u0026#34;/user/:name/*action\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) action := c.Param(\u0026#34;action\u0026#34;) message := name + \u0026#34; is \u0026#34; + action c.String(http.StatusOK, message) }) router.Run(\u0026#34;:8080\u0026#34;) } 获取url查询参数 func main() { router := gin.Default() // Query string parameters are parsed using the existing underlying request object. \t// The request responds to a url matching: /welcome?firstname=Jane\u0026amp;lastname=Doe \trouter.GET(\u0026#34;/welcome\u0026#34;, func(c *gin.Context) { firstname := c.DefaultQuery(\u0026#34;firstname\u0026#34;, \u0026#34;Guest\u0026#34;) lastname := c.Query(\u0026#34;lastname\u0026#34;) // shortcut for c.Request.URL.Query().Get(\u0026#34;lastname\u0026#34;)  c.String(http.StatusOK, \u0026#34;Hello %s %s\u0026#34;, firstname, lastname) }) router.Run(\u0026#34;:8080\u0026#34;) } Multipart Urlencoded 表单 func main() { router := gin.Default() router.POST(\u0026#34;/form_post\u0026#34;, func(c *gin.Context) { message := c.PostForm(\u0026#34;message\u0026#34;) nick := c.DefaultPostForm(\u0026#34;nick\u0026#34;, \u0026#34;anonymous\u0026#34;) c.JSON(200, gin.H{ \u0026#34;status\u0026#34;: \u0026#34;posted\u0026#34;, \u0026#34;message\u0026#34;: message, \u0026#34;nick\u0026#34;: nick, }) }) router.Run(\u0026#34;:8080\u0026#34;) } 获取post表单数据（url带查询参数） POST /post?id=1234\u0026amp;page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=manu\u0026amp;message=this_is_great  func main() { router := gin.Default() router.POST(\u0026#34;/post\u0026#34;, func(c *gin.Context) { id := c.Query(\u0026#34;id\u0026#34;) page := c.DefaultQuery(\u0026#34;page\u0026#34;, \u0026#34;0\u0026#34;) name := c.PostForm(\u0026#34;name\u0026#34;) message := c.PostForm(\u0026#34;message\u0026#34;) fmt.Printf(\u0026#34;id: %s; page: %s; name: %s; message: %s\u0026#34;, id, page, name, message) }) router.Run(\u0026#34;:8080\u0026#34;) } id: 1234; page: 1; name: manu; message: this_is_great  映射参数 表单参数 POST /post?ids[a]=1234\u0026amp;ids[b]=hello HTTP/1.1 Content-Type: application/x-www-form-urlencoded names[first]=thinkerou\u0026amp;names[second]=tianou  func main() { router := gin.Default() router.POST(\u0026#34;/post\u0026#34;, func(c *gin.Context) { ids := c.QueryMap(\u0026#34;ids\u0026#34;) names := c.PostFormMap(\u0026#34;names\u0026#34;) fmt.Printf(\u0026#34;ids: %v; names: %v\u0026#34;, ids, names) }) router.Run(\u0026#34;:8080\u0026#34;) } ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou]  上传文件 单个文件上传 参考问题＃774和详细示例代码。\nfunc main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) \t// router.MaxMultipartMemory = 8 \u0026lt;\u0026lt; 20 // 8 MiB \trouter.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { // single file \tfile, _ := c.FormFile(\u0026#34;file\u0026#34;) log.Println(file.Filename) // Upload the file to specific dst. \t// c.SaveUploadedFile(file, dst)  c.String(http.StatusOK, fmt.Sprintf(\u0026#34;\u0026#39;%s\u0026#39; uploaded!\u0026#34;, file.Filename)) }) router.Run(\u0026#34;:8080\u0026#34;) } curl示例:\ncurl -X POST http://localhost:8080/upload \\  -F \u0026#34;file=@/Users/appleboy/test.zip\u0026#34; \\  -H \u0026#34;Content-Type: multipart/form-data\u0026#34; 多文件上传 查看详细信息示例代码。\nfunc main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) \t// router.MaxMultipartMemory = 8 \u0026lt;\u0026lt; 20 // 8 MiB \trouter.POST(\u0026#34;/upload\u0026#34;, func(c *gin.Context) { // Multipart form \tform, _ := c.MultipartForm() files := form.File[\u0026#34;upload[]\u0026#34;] for _, file := range files { log.Println(file.Filename) // Upload the file to specific dst. \t// c.SaveUploadedFile(file, dst) \t} c.String(http.StatusOK, fmt.Sprintf(\u0026#34;%d files uploaded!\u0026#34;, len(files))) }) router.Run(\u0026#34;:8080\u0026#34;) } curl示例:\ncurl -X POST http://localhost:8080/upload \\  -F \u0026#34;upload[]=@/Users/appleboy/test1.zip\u0026#34; \\  -F \u0026#34;upload[]=@/Users/appleboy/test2.zip\u0026#34; \\  -H \u0026#34;Content-Type: multipart/form-data\u0026#34; 路由组 func main() { router := gin.Default() // Simple group: v1 \tv1 := router.Group(\u0026#34;/v1\u0026#34;) { v1.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v1.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v1.POST(\u0026#34;/read\u0026#34;, readEndpoint) } // Simple group: v2 \tv2 := router.Group(\u0026#34;/v2\u0026#34;) { v2.POST(\u0026#34;/login\u0026#34;, loginEndpoint) v2.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) v2.POST(\u0026#34;/read\u0026#34;, readEndpoint) } router.Run(\u0026#34;:8080\u0026#34;) } 默认初始化 Gin 用\nr := gin.New() 代替\n// Default With the Logger and Recovery middleware already attached r := gin.Default() 使用中间件 func main() { // Creates a router without any middleware by default \tr := gin.New() // Global middleware \t// Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release. \t// By default gin.DefaultWriter = os.Stdout \tr.Use(gin.Logger()) // Recovery middleware recovers from any panics and writes a 500 if there was one. \tr.Use(gin.Recovery()) // Per route middleware, you can add as many as you desire. \tr.GET(\u0026#34;/benchmark\u0026#34;, MyBenchLogger(), benchEndpoint) // Authorization group \t// authorized := r.Group(\u0026#34;/\u0026#34;, AuthRequired()) \t// exactly the same as: \tauthorized := r.Group(\u0026#34;/\u0026#34;) // per group middleware! in this case we use the custom created \t// AuthRequired() middleware just in the \u0026#34;authorized\u0026#34; group. \tauthorized.Use(AuthRequired()) { authorized.POST(\u0026#34;/login\u0026#34;, loginEndpoint) authorized.POST(\u0026#34;/submit\u0026#34;, submitEndpoint) authorized.POST(\u0026#34;/read\u0026#34;, readEndpoint) // nested group \ttesting := authorized.Group(\u0026#34;testing\u0026#34;) testing.GET(\u0026#34;/analytics\u0026#34;, analyticsEndpoint) } // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } 如何记录日志 func main() { // Disable Console Color, you don\u0026#39;t need console color when writing the logs to file.  gin.DisableConsoleColor() // Logging to a file.  f, _ := os.Create(\u0026#34;gin.log\u0026#34;) gin.DefaultWriter = io.MultiWriter(f) // Use the following code if you need to write the logs to file and console at the same time.  // gin.DefaultWriter = io.MultiWriter(f, os.Stdout)  router := gin.Default() router.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) router.Run(\u0026#34;:8080\u0026#34;) } 模型绑定和验证 要将请求主体绑定到类型中，请使用模型绑定。我们目前支持JSON，XML和标准表单值的绑定（foo = bar＆boo = baz）。\nGin使用** go-playground/validator.v8 **进行验证。检查有关标签用法的完整文档此处。\n请注意，您需要在要绑定的所有字段上设置相应的绑定标记。例如，从JSON绑定时，设置json：“fieldname”。\n此外，Gin提供了两组绑定方法： - 类型 - 必须绑定 - 方法 - Bind，BindJSON，BindXML，BindQuery - 行为 - 这些方法在引擎盖下使用MustBindWith。如果存在绑定错误，则使用c.AbortWithError(400，err).SetType(ErrorTypeBind)中止请求。这将响应状态代码设置为400，并将Content-Type标头设置为text/plain;字符集= UTF-8。请注意，如果您在此之后尝试设置响应代码，则会发出警告“[GIN-debug] [警告]标题已经写入。想用422覆盖状态代码400。如果您希望更好地控制行为，请考虑使用ShouldBind等效方法。 - **类型** - 应该绑定 - **方法** -ShouldBind，ShouldBindJSON，ShouldBindXML，ShouldBindQuery - **行为** - 这些方法在引擎盖下使用ShouldBindWith`。如果存在绑定错误，则返回错误，开发人员有责任正确处理请求和错误。\n使用Bind方法时，Gin会尝试根据Content-Type标头推断出绑定器。如果你确定你绑定了什么，你可以使用 MustBindWith 或 ShouldBindWith。\n您还可以指定需要特定字段。如果字段用 binding：“必需” 来装饰，并且在绑定时具有空值，则会返回错误。\n// Binding from JSON type Login struct { User string `form:\u0026#34;user\u0026#34; json:\u0026#34;user\u0026#34; xml:\u0026#34;user\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `form:\u0026#34;password\u0026#34; json:\u0026#34;password\u0026#34; xml:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { router := gin.Default() // Example for binding JSON ({\u0026#34;user\u0026#34;: \u0026#34;manu\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123\u0026#34;}) \trouter.POST(\u0026#34;/loginJSON\u0026#34;, func(c *gin.Context) { var json Login if err := c.ShouldBindJSON(\u0026amp;json); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if json.User != \u0026#34;manu\u0026#34; || json.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Example for binding XML ( \t//\t\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \t//\t\u0026lt;root\u0026gt; \t//\t\u0026lt;user\u0026gt;user\u0026lt;/user\u0026gt; \t//\t\u0026lt;password\u0026gt;123\u0026lt;/user\u0026gt; \t//\t\u0026lt;/root\u0026gt;) \trouter.POST(\u0026#34;/loginXML\u0026#34;, func(c *gin.Context) { var xml Login if err := c.ShouldBindXML(\u0026amp;xml); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if xml.User != \u0026#34;manu\u0026#34; || xml.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Example for binding a HTML form (user=manu\u0026amp;password=123) \trouter.POST(\u0026#34;/loginForm\u0026#34;, func(c *gin.Context) { var form Login // This will infer what binder to use depending on the content-type header. \tif err := c.ShouldBind(\u0026amp;form); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if form.User != \u0026#34;manu\u0026#34; || form.Password != \u0026#34;123\u0026#34; { c.JSON(http.StatusUnauthorized, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) }) // Listen and serve on 0.0.0.0:8080 \trouter.Run(\u0026#34;:8080\u0026#34;) } 简单请求\n$ curl -v -X POST \\  http://localhost:8080/loginJSON \\  -H \u0026#39;content-type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;user\u0026#34;: \u0026#34;manu\u0026#34; }\u0026#39; \u0026gt; POST /loginJSON HTTP/1.1 \u0026gt; Host: localhost:8080 \u0026gt; User-Agent: curl/7.51.0 \u0026gt; Accept: */* \u0026gt; content-type: application/json \u0026gt; Content-Length: 18 \u0026gt; * upload completely sent off: 18 out of 18 bytes \u0026lt; HTTP/1.1 400 Bad Request \u0026lt; Content-Type: application/json; charset=utf-8 \u0026lt; Date: Fri, 04 Aug 2017 03:51:31 GMT \u0026lt; Content-Length: 100 \u0026lt; {\u0026#34;error\u0026#34;:\u0026#34;Key: \u0026#39;Login.Password\u0026#39; Error:Field validation for \u0026#39;Password\u0026#39; failed on the \u0026#39;required\u0026#39; tag\u0026#34;} 跳过验证\n使用上面 的curl 命令运行上面的例子时，它返回错误。 因为这个例子使用 binding：'需要。 如果使用 `binding：“ -`，那么在再次运行上面的例子时它不会返回错误。\n自定义验证器 也可以注册自定义验证器。 请参阅示例代码。\nembedmd：＃(examples/custom-validation/server.go go)\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/gin-gonic/gin/binding\u0026#34; \u0026#34;gopkg.in/go-playground/validator.v8\u0026#34; ) // Booking contains binded and validated data. type Booking struct { CheckIn time.Time `form:\u0026#34;check_in\u0026#34; binding:\u0026#34;required,bookabledate\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34;` CheckOut time.Time `form:\u0026#34;check_out\u0026#34; binding:\u0026#34;required,gtfield=CheckIn\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34;` } func bookableDate( v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string, ) bool { if date, ok := field.Interface().(time.Time); ok { today := time.Now() if today.Year() \u0026gt; date.Year() || today.YearDay() \u0026gt; date.YearDay() { return false } } return true } func main() { route := gin.Default() if v, ok := binding.Validator.Engine().(*validator.Validate); ok { v.RegisterValidation(\u0026#34;bookabledate\u0026#34;, bookableDate) } route.GET(\u0026#34;/bookable\u0026#34;, getBookable) route.Run(\u0026#34;:8085\u0026#34;) } func getBookable(c *gin.Context) { var b Booking if err := c.ShouldBindWith(\u0026amp;b, binding.Query); err == nil { c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;Booking dates are valid!\u0026#34;}) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }$ curl \u0026#34;localhost:8085/bookable?check_in=2018-04-16\u0026amp;check_out=2018-04-17\u0026#34; {\u0026#34;message\u0026#34;:\u0026#34;Booking dates are valid!\u0026#34;} $ curl \u0026#34;localhost:8085/bookable?check_in=2018-03-08\u0026amp;check_out=2018-03-09\u0026#34; {\u0026#34;error\u0026#34;:\u0026#34;Key: \u0026#39;Booking.CheckIn\u0026#39; Error:Field validation for \u0026#39;CheckIn\u0026#39; failed on the \u0026#39;bookabledate\u0026#39; tag\u0026#34;} 结构级验证也可以这种方式注册。 请参阅struct-lvl-validation示例以了解更多信息。\n只绑定url查询参数 ShouldBindQuery 函数只绑定url查询参数而不是post字段。 请参阅详细信息。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Person struct { Name string `form:\u0026#34;name\u0026#34;` Address string `form:\u0026#34;address\u0026#34;` } func main() { route := gin.Default() route.Any(\u0026#34;/testing\u0026#34;, startPage) route.Run(\u0026#34;:8085\u0026#34;) } func startPage(c *gin.Context) { var person Person if c.ShouldBindQuery(\u0026amp;person) == nil { log.Println(\u0026#34;====== Only Bind By Query String ======\u0026#34;) log.Println(person.Name) log.Println(person.Address) } c.String(200, \u0026#34;Success\u0026#34;) } url查询参数绑定到struct（或POST表单数据） 请参阅详细信息。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Person struct { Name string `form:\u0026#34;name\u0026#34;` Address string `form:\u0026#34;address\u0026#34;` Birthday time.Time `form:\u0026#34;birthday\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34; time_utc:\u0026#34;1\u0026#34;` } func main() { route := gin.Default() route.GET(\u0026#34;/testing\u0026#34;, startPage) route.Run(\u0026#34;:8085\u0026#34;) } func startPage(c *gin.Context) { var person Person // If `GET`, only `Form` binding engine (`query`) used. \t// If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`). \t// See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48 \tif c.ShouldBind(\u0026amp;person) == nil { log.Println(person.Name) log.Println(person.Address) log.Println(person.Birthday) } c.String(200, \u0026#34;Success\u0026#34;) } 测试:\n$ curl -X GET \u0026#34;localhost:8085/testing?name=appleboy\u0026amp;address=xyz\u0026amp;birthday=1992-03-15\u0026#34; 绑定 HTML 复选框 参见详细信息\nmain.go\n... type myForm struct { Colors []string `form:\u0026#34;colors[]\u0026#34;` } ... func formHandler(c *gin.Context) { var fakeForm myForm c.ShouldBind(\u0026amp;fakeForm) c.JSON(200, gin.H{\u0026#34;color\u0026#34;: fakeForm.Colors}) } ... form.html\n\u0026lt;form action=\u0026#34;/\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Check some colors\u0026lt;/p\u0026gt; \u0026lt;label for=\u0026#34;red\u0026#34;\u0026gt;Red\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;red\u0026#34; id=\u0026#34;red\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;green\u0026#34;\u0026gt;Green\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;green\u0026#34; id=\u0026#34;green\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;blue\u0026#34;\u0026gt;Blue\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;blue\u0026#34; id=\u0026#34;blue\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; result:\n{\u0026quot;color\u0026quot;:[\u0026quot;red\u0026quot;,\u0026quot;green\u0026quot;,\u0026quot;blue\u0026quot;]}  Multipart Urlencoded 绑定 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type LoginForm struct { User string `form:\u0026#34;user\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `form:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { router := gin.Default() router.POST(\u0026#34;/login\u0026#34;, func(c *gin.Context) { // you can bind multipart form with explicit binding declaration: \t// c.ShouldBindWith(\u0026amp;form, binding.Form) \t// or you can simply use autobinding with ShouldBind method: \tvar form LoginForm // in this case proper binding will be automatically selected \tif c.ShouldBind(\u0026amp;form) == nil { if form.User == \u0026#34;user\u0026#34; \u0026amp;\u0026amp; form.Password == \u0026#34;password\u0026#34; { c.JSON(200, gin.H{\u0026#34;status\u0026#34;: \u0026#34;you are logged in\u0026#34;}) } else { c.JSON(401, gin.H{\u0026#34;status\u0026#34;: \u0026#34;unauthorized\u0026#34;}) } } }) router.Run(\u0026#34;:8080\u0026#34;) } 测试:\n$ curl -v --form user=user --form password=password http://localhost:8080/login XML JSON YAML ProtoBuf 渲染 func main() { r := gin.Default() // gin.H is a shortcut for map[string]interface{} \tr.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/moreJSON\u0026#34;, func(c *gin.Context) { // You also can use a struct \tvar msg struct { Name string `json:\u0026#34;user\u0026#34;` Message string Number int } msg.Name = \u0026#34;Lena\u0026#34; msg.Message = \u0026#34;hey\u0026#34; msg.Number = 123 // Note that msg.Name becomes \u0026#34;user\u0026#34; in the JSON \t// Will output : {\u0026#34;user\u0026#34;: \u0026#34;Lena\u0026#34;, \u0026#34;Message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;Number\u0026#34;: 123} \tc.JSON(http.StatusOK, msg) }) r.GET(\u0026#34;/someXML\u0026#34;, func(c *gin.Context) { c.XML(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/someYAML\u0026#34;, func(c *gin.Context) { c.YAML(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;hey\u0026#34;, \u0026#34;status\u0026#34;: http.StatusOK}) }) r.GET(\u0026#34;/someProtoBuf\u0026#34;, func(c *gin.Context) { reps := []int64{int64(1), int64(2)} label := \u0026#34;test\u0026#34; // The specific definition of protobuf is written in the testdata/protoexample file. \tdata := \u0026amp;protoexample.Test{ Label: \u0026amp;label, Reps: reps, } // Note that data becomes binary data in the response \t// Will output protoexample.Test protobuf serialized data \tc.ProtoBuf(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } SecureJSON 使用 SecureJSON 来防止 json 劫持。 如果给定的结构是数组值，则默认预 置“while(1)，” 到响应体。\nfunc main() { r := gin.Default() // You can also use your own secure json prefix \t// r.SecureJsonPrefix(\u0026#34;)]}\u0026#39;,\\n\u0026#34;)  r.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { names := []string{\u0026#34;lena\u0026#34;, \u0026#34;austin\u0026#34;, \u0026#34;foo\u0026#34;} // Will output : while(1);[\u0026#34;lena\u0026#34;,\u0026#34;austin\u0026#34;,\u0026#34;foo\u0026#34;] \tc.SecureJSON(http.StatusOK, names) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } JSONP 使用 JSONP 从不同域中的服务器请求数据。 如果查询参数回调存在，则将回调添加到响应正文。\nfunc main() { r := gin.Default() r.GET(\u0026#34;/JSONP?callback=x\u0026#34;, func(c *gin.Context) { data := map[string]interface{}{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, } //callback is x \t// Will output : x({\\\u0026#34;foo\\\u0026#34;:\\\u0026#34;bar\\\u0026#34;}) \tc.JSONP(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } AsciiJSON 使用 Ascii JSON 生成具有转义的非 ASCII 字符的仅 ASCII JSON。\nfunc main() { r := gin.Default() r.GET(\u0026#34;/someJSON\u0026#34;, func(c *gin.Context) { data := map[string]interface{}{ \u0026#34;lang\u0026#34;: \u0026#34;GO语言\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\u0026lt;br\u0026gt;\u0026#34;, } // will output : {\u0026#34;lang\u0026#34;:\u0026#34;GO\\u8bed\\u8a00\u0026#34;,\u0026#34;tag\u0026#34;:\u0026#34;\\u003cbr\\u003e\u0026#34;} \tc.AsciiJSON(http.StatusOK, data) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } PureJSON 通常，JSON使用unicode替换特殊HTML字符，例如 \u0026lt; 变为 \\ u003c。 如果要按字面意思对这些字符进行编码，则可以使用 PureJSON。 Go 1.6及更低版本无法使用此功能。\nfunc main() { r := gin.Default() // Serves unicode entities \tr.GET(\u0026#34;/json\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;html\u0026#34;: \u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;, }) }) // Serves literal characters \tr.GET(\u0026#34;/purejson\u0026#34;, func(c *gin.Context) { c.PureJSON(200, gin.H{ \u0026#34;html\u0026#34;: \u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;, }) }) // listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080) } 静态文件服务 func main() { router := gin.Default() router.Static(\u0026#34;/assets\u0026#34;, \u0026#34;./assets\u0026#34;) router.StaticFS(\u0026#34;/more_static\u0026#34;, http.Dir(\u0026#34;my_file_system\u0026#34;)) router.StaticFile(\u0026#34;/favicon.ico\u0026#34;, \u0026#34;./resources/favicon.ico\u0026#34;) // Listen and serve on 0.0.0.0:8080 \trouter.Run(\u0026#34;:8080\u0026#34;) } 从 reader 读取数据 func main() { router := gin.Default() router.GET(\u0026#34;/someDataFromReader\u0026#34;, func(c *gin.Context) { response, err := http.Get(\u0026#34;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\u0026#34;) if err != nil || response.StatusCode != http.StatusOK { c.Status(http.StatusServiceUnavailable) return } reader := response.Body contentLength := response.ContentLength contentType := response.Header.Get(\u0026#34;Content-Type\u0026#34;) extraHeaders := map[string]string{ \u0026#34;Content-Disposition\u0026#34;: `attachment; filename=\u0026#34;gopher.png\u0026#34;`, } c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders) }) router.Run(\u0026#34;:8080\u0026#34;) } HTML 渲染 使用LoadHTMLGlob()或LoadHTMLFiles()\nfunc main() { router := gin.Default() router.LoadHTMLGlob(\u0026#34;templates/*\u0026#34;) //router.LoadHTMLFiles(\u0026#34;templates/template1.html\u0026#34;, \u0026#34;templates/template2.html\u0026#34;) \trouter.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Main website\u0026#34;, }) }) router.Run(\u0026#34;:8080\u0026#34;) } templates/index.tmpl\n\u0026lt;html\u0026gt; \u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;/html\u0026gt; 在不同目录中使用具有相同名称的模板\nfunc main() { router := gin.Default() router.LoadHTMLGlob(\u0026#34;templates/**/*\u0026#34;) router.GET(\u0026#34;/posts/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;posts/index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Posts\u0026#34;, }) }) router.GET(\u0026#34;/users/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;users/index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;Users\u0026#34;, }) }) router.Run(\u0026#34;:8080\u0026#34;) } templates/posts/index.tmpl\n{{ define \u0026#34;posts/index.tmpl\u0026#34; }} \u0026lt;html\u0026gt;\u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Using posts/index.tmpl\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; {{ end }} templates/users/index.tmpl\n{{ define \u0026#34;users/index.tmpl\u0026#34; }} \u0026lt;html\u0026gt;\u0026lt;h1\u0026gt; {{ .title }} \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Using users/index.tmpl\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; {{ end }} 自定义模板渲染器 您还可以使用自己的 html 模板渲染\nimport \u0026#34;html/template\u0026#34; func main() { router := gin.Default() html := template.Must(template.ParseFiles(\u0026#34;file1\u0026#34;, \u0026#34;file2\u0026#34;)) router.SetHTMLTemplate(html) router.Run(\u0026#34;:8080\u0026#34;) } 自定义分隔符 您可以使用自定义分隔\nr := gin.Default() r.Delims(\u0026#34;{[{\u0026#34;, \u0026#34;}]}\u0026#34;) r.LoadHTMLGlob(\u0026#34;/path/to/templates\u0026#34;) 自定义模板功能 查看详细信息示例代码。\nmain.go\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func formatAsDate(t time.Time) string { year, month, day := t.Date() return fmt.Sprintf(\u0026#34;%d%02d/%02d\u0026#34;, year, month, day) } func main() { router := gin.Default() router.Delims(\u0026#34;{[{\u0026#34;, \u0026#34;}]}\u0026#34;) router.SetFuncMap(template.FuncMap{ \u0026#34;formatAsDate\u0026#34;: formatAsDate, }) router.LoadHTMLFiles(\u0026#34;./testdata/template/raw.tmpl\u0026#34;) router.GET(\u0026#34;/raw\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;raw.tmpl\u0026#34;, map[string]interface{}{ \u0026#34;now\u0026#34;: time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC), }) }) router.Run(\u0026#34;:8080\u0026#34;) } raw.tmpl\n日期: {[{.now | formatAsDate}]} 结果:\nDate: 2017/07/01  多模板 Gin 允许默认只使用一个 html 模板。 检查多模板渲染以使用 go 1.6 block template 等功能。\n重定向 发起HTTP重定向很简单。支持内部和外部重定向。\nr.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \u0026#34;http://www.google.com/\u0026#34;) }) 发起路由器内部重定向，使用如下的HandleContext。\nr.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.Request.URL.Path = \u0026#34;/test2\u0026#34; r.HandleContext(c) }) r.GET(\u0026#34;/test2\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;}) }) 自定义中间件 func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // Set example variable \tc.Set(\u0026#34;example\u0026#34;, \u0026#34;12345\u0026#34;) // before request  c.Next() // after request \tlatency := time.Since(t) log.Print(latency) // access the status we are sending \tstatus := c.Writer.Status() log.Println(status) } } func main() { r := gin.New() r.Use(Logger()) r.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { example := c.MustGet(\u0026#34;example\u0026#34;).(string) // it would print: \u0026#34;12345\u0026#34; \tlog.Println(example) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } BasicAuth() 中间件 // simulate some private data var secrets = gin.H{ \u0026#34;foo\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;123433\u0026#34;}, \u0026#34;austin\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;austin@example.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;666\u0026#34;}, \u0026#34;lena\u0026#34;: gin.H{\u0026#34;email\u0026#34;: \u0026#34;lena@guapa.com\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;523443\u0026#34;}, } func main() { r := gin.Default() // Group using gin.BasicAuth() middleware \t// gin.Accounts is a shortcut for map[string]string \tauthorized := r.Group(\u0026#34;/admin\u0026#34;, gin.BasicAuth(gin.Accounts{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;austin\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;lena\u0026#34;: \u0026#34;hello2\u0026#34;, \u0026#34;manu\u0026#34;: \u0026#34;4321\u0026#34;, })) // /admin/secrets endpoint \t// hit \u0026#34;localhost:8080/admin/secrets \tauthorized.GET(\u0026#34;/secrets\u0026#34;, func(c *gin.Context) { // get user, it was set by the BasicAuth middleware \tuser := c.MustGet(gin.AuthUserKey).(string) if secret, ok := secrets[user]; ok { c.JSON(http.StatusOK, gin.H{\u0026#34;user\u0026#34;: user, \u0026#34;secret\u0026#34;: secret}) } else { c.JSON(http.StatusOK, gin.H{\u0026#34;user\u0026#34;: user, \u0026#34;secret\u0026#34;: \u0026#34;NO SECRET :(\u0026#34;}) } }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } Goroutines 当在中间件或处理程序中启动新的 Goroutines 时，你不应该**使用其中的原始上下文，你必须使用只读副本。\nfunc main() { r := gin.Default() r.GET(\u0026#34;/long_async\u0026#34;, func(c *gin.Context) { // create copy to be used inside the goroutine \tcCp := c.Copy() go func() { // simulate a long task with time.Sleep(). 5 seconds \ttime.Sleep(5 * time.Second) // note that you are using the copied context \u0026#34;cCp\u0026#34;, IMPORTANT \tlog.Println(\u0026#34;Done! in path \u0026#34; + cCp.Request.URL.Path) }() }) r.GET(\u0026#34;/long_sync\u0026#34;, func(c *gin.Context) { // simulate a long task with time.Sleep(). 5 seconds \ttime.Sleep(5 * time.Second) // since we are NOT using a goroutine, we do not have to copy the context \tlog.Println(\u0026#34;Done! in path \u0026#34; + c.Request.URL.Path) }) // Listen and serve on 0.0.0.0:8080 \tr.Run(\u0026#34;:8080\u0026#34;) } 自定义 HTTP 配置 直接使用http.ListenAndServe()，如下所示：\nfunc main() { router := gin.Default() http.ListenAndServe(\u0026#34;:8080\u0026#34;, router) } or\nfunc main() { router := gin.Default() s := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u0026lt;\u0026lt; 20, } s.ListenAndServe() } Let\u0026rsquo;s Encrypt 支持 一行代码支持 LetsEncrypt HTTPS示例。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/autotls\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() // Ping handler \tr.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) log.Fatal(autotls.Run(r, \u0026#34;example1.com\u0026#34;, \u0026#34;example2.com\u0026#34;)) } autocert使用示例。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/autotls\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;golang.org/x/crypto/acme/autocert\u0026#34; ) func main() { r := gin.Default() // Ping handler \tr.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) m := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(\u0026#34;example1.com\u0026#34;, \u0026#34;example2.com\u0026#34;), Cache: autocert.DirCache(\u0026#34;/var/www/.cache\u0026#34;), } log.Fatal(autotls.RunWithManager(r, \u0026amp;m)) } 使用 Gin 运行多个服务 请参阅问题并尝试以下示例：\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) var ( g errgroup.Group ) func router01() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: http.StatusOK, \u0026#34;error\u0026#34;: \u0026#34;Welcome server 01\u0026#34;, }, ) }) return e } func router02() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: http.StatusOK, \u0026#34;error\u0026#34;: \u0026#34;Welcome server 02\u0026#34;, }, ) }) return e } func main() { server01 := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router01(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } server02 := \u0026amp;http.Server{ Addr: \u0026#34;:8081\u0026#34;, Handler: router02(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, } g.Go(func() error { return server01.ListenAndServe() }) g.Go(func() error { return server02.ListenAndServe() }) if err := g.Wait(); err != nil { log.Fatal(err) } } 优雅重启或停止 您想要优雅地重启或停止您的Web服务器吗？ 有一些方法可以做到这一点。\n我们可以使用fvbock/endless来替换默认的ListenAndServe。 有关更多详细信息，请参阅问题＃296。\nrouter := gin.Default() router.GET(\u0026#34;/\u0026#34;, handler) // [...] endless.ListenAndServe(\u0026#34;:4242\u0026#34;, router) 替代方案：\n manners：礼貌的Go HTTP服务器，可以正常关闭。 graceful：Graceful是一个Go包，可以正常关闭http.Handler服务器。 grace：Go服务器的平滑重启和零停机时间部署。  如果您使用的是Go 1.8，可以考虑使用http.Server内置Shutdown()方法进行正常关机。 请参阅gin的完整graceful-shutdown示例。\n// +build go1.8  package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { router := gin.Default() router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { time.Sleep(5 * time.Second) c.String(http.StatusOK, \u0026#34;Welcome Gin Server\u0026#34;) }) srv := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router, } go func() { // service connections \tif err := srv.ListenAndServe(); err != nil \u0026amp;\u0026amp; err != http.ErrServerClosed { log.Fatalf(\u0026#34;listen: %s\\n\u0026#34;, err) } }() // Wait for interrupt signal to gracefully shutdown the server with \t// a timeout of 5 seconds. \tquit := make(chan os.Signal) signal.Notify(quit, os.Interrupt) \u0026lt;-quit log.Println(\u0026#34;Shutdown Server ...\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() if err := srv.Shutdown(ctx); err != nil { log.Fatal(\u0026#34;Server Shutdown:\u0026#34;, err) } log.Println(\u0026#34;Server exiting\u0026#34;) } 使用模板构建单个二进制文件 您可以使用[go-assets]将服务器打包为包含模板的单个二进制可执行文件。\n[go-assets]：https：//github.com/jessevdk/go-assets\nfunc main() { r := gin.New() t, err := loadTemplate() if err != nil { panic(err) } r.SetHTMLTemplate(t) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;/html/index.tmpl\u0026#34;,nil) }) r.Run(\u0026#34;:8080\u0026#34;) } // loadTemplate loads templates embedded by go-assets-builder func loadTemplate() (*template.Template, error) { t := template.New(\u0026#34;\u0026#34;) for name, file := range Assets.Files { if file.IsDir() || !strings.HasSuffix(name, \u0026#34;.tmpl\u0026#34;) { continue } h, err := ioutil.ReadAll(file) if err != nil { return nil, err } t, err = t.New(name).Parse(string(h)) if err != nil { return nil, err } } return t, nil } 请参阅examples/assets-in-binary目录中的完整示例。\n表单数据绑定到自定义结构体 以下示例使用自定义结构：\ntype StructA struct { FieldA string `form:\u0026#34;field_a\u0026#34;` } type StructB struct { NestedStruct StructA FieldB string `form:\u0026#34;field_b\u0026#34;` } type StructC struct { NestedStructPointer *StructA FieldC string `form:\u0026#34;field_c\u0026#34;` } type StructD struct { NestedAnonyStruct struct { FieldX string `form:\u0026#34;field_x\u0026#34;` } FieldD string `form:\u0026#34;field_d\u0026#34;` } func GetDataB(c *gin.Context) { var b StructB c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;a\u0026#34;: b.NestedStruct, \u0026#34;b\u0026#34;: b.FieldB, }) } func GetDataC(c *gin.Context) { var b StructC c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;a\u0026#34;: b.NestedStructPointer, \u0026#34;c\u0026#34;: b.FieldC, }) } func GetDataD(c *gin.Context) { var b StructD c.Bind(\u0026amp;b) c.JSON(200, gin.H{ \u0026#34;x\u0026#34;: b.NestedAnonyStruct, \u0026#34;d\u0026#34;: b.FieldD, }) } func main() { r := gin.Default() r.GET(\u0026#34;/getb\u0026#34;, GetDataB) r.GET(\u0026#34;/getc\u0026#34;, GetDataC) r.GET(\u0026#34;/getd\u0026#34;, GetDataD) r.Run() } 使用命令curl命令结果：\n$ curl \u0026quot;http://localhost:8080/getb?field_a=hello\u0026amp;field_b=world\u0026quot; {\u0026quot;a\u0026quot;:{\u0026quot;FieldA\u0026quot;:\u0026quot;hello\u0026quot;},\u0026quot;b\u0026quot;:\u0026quot;world\u0026quot;} $ curl \u0026quot;http://localhost:8080/getc?field_a=hello\u0026amp;field_c=world\u0026quot; {\u0026quot;a\u0026quot;:{\u0026quot;FieldA\u0026quot;:\u0026quot;hello\u0026quot;},\u0026quot;c\u0026quot;:\u0026quot;world\u0026quot;} $ curl \u0026quot;http://localhost:8080/getd?field_x=hello\u0026amp;field_d=world\u0026quot; {\u0026quot;d\u0026quot;:\u0026quot;world\u0026quot;,\u0026quot;x\u0026quot;:{\u0026quot;FieldX\u0026quot;:\u0026quot;hello\u0026quot;}}  注意:不支持以下样式结构：\ntype StructX struct { X struct {} `form:\u0026#34;name_x\u0026#34;` // HERE have form } type StructY struct { Y StructX `form:\u0026#34;name_y\u0026#34;` // HERE have form } type StructZ struct { Z *StructZ `form:\u0026#34;name_z\u0026#34;` // HERE have form } 总之，只支持现在没有form的嵌套自定义结构。\n将request body绑定到不同的结构体中 一般通过调用c.Request.Body方法绑定数据，但不能多次调用这个方法。\ntype formA struct { Foo string `json:\u0026#34;foo\u0026#34; xml:\u0026#34;foo\u0026#34; binding:\u0026#34;required\u0026#34;` } type formB struct { Bar string `json:\u0026#34;bar\u0026#34; xml:\u0026#34;bar\u0026#34; binding:\u0026#34;required\u0026#34;` } func SomeHandler(c *gin.Context) { objA := formA{} objB := formB{} // This c.ShouldBind consumes c.Request.Body and it cannot be reused.  if errA := c.ShouldBind(\u0026amp;objA); errA == nil { c.String(http.StatusOK, `the body should be formA`) // Always an error is occurred by this because c.Request.Body is EOF now.  } else if errB := c.ShouldBind(\u0026amp;objB); errB == nil { c.String(http.StatusOK, `the body should be formB`) } else { ... } } 为此，要想多次绑定，需要使用c.ShouldBindBodyWith.\nfunc SomeHandler(c *gin.Context) { objA := formA{} objB := formB{} // This reads c.Request.Body and stores the result into the context.  if errA := c.ShouldBindBodyWith(\u0026amp;objA, binding.JSON); errA == nil { c.String(http.StatusOK, `the body should be formA`) // At this time, it reuses body stored in the context.  } else if errB := c.ShouldBindBodyWith(\u0026amp;objB, binding.JSON); errB == nil { c.String(http.StatusOK, `the body should be formB JSON`) // And it can accepts other formats  } else if errB2 := c.ShouldBindBodyWith(\u0026amp;objB, binding.XML); errB2 == nil { c.String(http.StatusOK, `the body should be formB XML`) } else { ... } } *c.ShouldBindBodyWith会在绑定之前将body存储到上下文中。 这会 对性能造成轻微影响，如果调用一次就能完成绑定的话，那就不要用这个方法。 *只有某些格式需要此功能 ，如“JSON”，“XML”，“MsgPack”， ProtoBuf。 对于其他格式，如Query，Form，FormPost，FormMultipart， 可以多次调用c.ShouldBind()而不会造成任任何性能损失（见＃1341）。\nhttp2 server 推送 http.Pusher仅支持** go1.8 + **。 有关详细信息，请参阅golang blog。\npackage main import ( \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) var html = template.Must(template.New(\u0026#34;https\u0026#34;).Parse(` \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Https Test\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;/assets/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;color:red;\u0026#34;\u0026gt;Welcome, Ginner!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; `)) func main() { r := gin.Default() r.Static(\u0026#34;/assets\u0026#34;, \u0026#34;./assets\u0026#34;) r.SetHTMLTemplate(html) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { if pusher := c.Writer.Pusher(); pusher != nil { // use pusher.Push() to do server push \tif err := pusher.Push(\u0026#34;/assets/app.js\u0026#34;, nil); err != nil { log.Printf(\u0026#34;Failed to push: %v\u0026#34;, err) } } c.HTML(200, \u0026#34;https\u0026#34;, gin.H{ \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, }) }) // Listen and Server in https://127.0.0.1:8080 \tr.RunTLS(\u0026#34;:8080\u0026#34;, \u0026#34;./testdata/server.pem\u0026#34;, \u0026#34;./testdata/server.key\u0026#34;) } 定义路由日志的格式 默认的路由日志格式：\n[GIN-debug] POST /foo --\u0026gt; main.main.func1 (3 handlers) [GIN-debug] GET /bar --\u0026gt; main.main.func2 (3 handlers) [GIN-debug] GET /status --\u0026gt; main.main.func3 (3 handlers)  如果要以指的格式（例如JSON，Key Values或其他格式）记录信息，则可以使用gin.DebugPrintRouteFunc指定格式。 在下面的示例中，我们使用标准日志包记录所有路由，但您可以使用其他满足需求的日志工具。\nimport ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) { log.Printf(\u0026#34;endpoint %v %v %v %v\\n\u0026#34;, httpMethod, absolutePath, handlerName, nuHandlers) } r.POST(\u0026#34;/foo\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;foo\u0026#34;) }) r.GET(\u0026#34;/bar\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;bar\u0026#34;) }) r.GET(\u0026#34;/status\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, \u0026#34;ok\u0026#34;) }) // Listen and Server in http://0.0.0.0:8080 \tr.Run() } 测试 HTTP测试首选net/http/httptest包。\npackage main func setupRouter() *gin.Engine { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;pong\u0026#34;) }) return r } func main() { r := setupRouter() r.Run(\u0026#34;:8080\u0026#34;) } 上面这段代码的测试用例：\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestPingRoute(t *testing.T) { router := setupRouter() w := httptest.NewRecorder() req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/ping\u0026#34;, nil) router.ServeHTTP(w, req) assert.Equal(t, 200, w.Code) assert.Equal(t, \u0026#34;pong\u0026#34;, w.Body.String()) } 用户 使用Gin框架的著名项目。\n drone：用Go编写的基于docker的持续集成平台。 gorush：用Go编写的推送通知服务。 fnproject：容器驱动、云无关的无服务器平台。 photoprism: 用Go编写的基于TensorFlow的个人相册管理系统.  "
}]